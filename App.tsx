import React, { useState, useCallback, useEffect } from 'react';
import Sidebar from './components/Sidebar';
import Dashboard from './components/Dashboard';
import OrderBook from './components/OrderBook';
import TeamManagement from './components/TeamManagement';
import TaskList from './components/TaskList';
import { INITIAL_TEAM } from './constants';
import { Project, ProjectStatus, TeamMember, Task, Order, OrderPriority, WorkTask, ProjectCategory, WorkTaskStatus, TaskRecurrence } from './types';

const STORAGE_KEYS = {
  PROJECTS: 'teampulse_projects',
  TEAM: 'teampulse_team',
  CENTRAL_TASKS: 'teampulse_central_tasks',
  WORK_TASKS: 'teampulse_work_tasks'
};

const App: React.FC = () => {
  const [view, setView] = useState<'dashboard' | 'orders' | 'team' | 'tasks'>('dashboard');
  
  // Initialize state with data from localStorage or an empty array
  const [projects, setProjects] = useState<Project[]>(() => {
    const saved = localStorage.getItem(STORAGE_KEYS.PROJECTS);
    return saved ? JSON.parse(saved) : [];
  });

  const [team, setTeam] = useState<TeamMember[]>(() => {
    const saved = localStorage.getItem(STORAGE_KEYS.TEAM);
    return saved ? JSON.parse(saved) : INITIAL_TEAM;
  });

  const [centralTaskList, setCentralTaskList] = useState<Task[]>(() => {
    const saved = localStorage.getItem(STORAGE_KEYS.CENTRAL_TASKS);
    return saved ? JSON.parse(saved) : [];
  });

  const [workTasks, setWorkTasks] = useState<WorkTask[]>(() => {
    const saved = localStorage.getItem(STORAGE_KEYS.WORK_TASKS);
    return saved ? JSON.parse(saved) : [];
  });

  // Save to localStorage whenever state changes
  useEffect(() => {
    localStorage.setItem(STORAGE_KEYS.PROJECTS, JSON.stringify(projects));
  }, [projects]);

  useEffect(() => {
    localStorage.setItem(STORAGE_KEYS.TEAM, JSON.stringify(team));
  }, [team]);

  useEffect(() => {
    localStorage.setItem(STORAGE_KEYS.CENTRAL_TASKS, JSON.stringify(centralTaskList));
  }, [centralTaskList]);

  useEffect(() => {
    localStorage.setItem(STORAGE_KEYS.WORK_TASKS, JSON.stringify(workTasks));
  }, [workTasks]);

  // Helper to generate Task IDs outside of the TaskList component
  const generateTaskIdForApp = (category: string, existingTasks: WorkTask[]) => {
    const now = new Date();
    const year = now.getFullYear();
    const month = String(now.getMonth() + 1).padStart(2, '0');
    const mainTasksCount = existingTasks.filter(t => !t.parentId && t.category === category).length;
    const sequence = String(mainTasksCount + 1).padStart(4, '0');
    return `${category}-${year}-${month}-${sequence}`;
  };

  const createWorkTaskFromProject = (project: Project, currentWorkTasks: WorkTask[]) => {
    // Check if a task for this project already exists in the WorkTask list 
    // to prevent duplicates during status flips
    const alreadyExists = currentWorkTasks.some(t => t.title === project.name && !t.parentId);
    if (alreadyExists) return currentWorkTasks;

    let taskCategory: 'CTB' | 'RTB' | 'SSP' | 'BAU' | 'Other';
    switch (project.category) {
      case ProjectCategory.CTB: taskCategory = 'CTB'; break;
      case ProjectCategory.RTB: taskCategory = 'RTB'; break;
      case ProjectCategory.SSP: taskCategory = 'SSP'; break;
      case ProjectCategory.BAU: taskCategory = 'BAU'; break;
      default: taskCategory = 'Other';
    }

    const taskId = generateTaskIdForApp(taskCategory, currentWorkTasks);

    const autoGeneratedTask: WorkTask = {
      id: taskId,
      parentId: null,
      title: project.name,
      category: taskCategory,
      assignedTo: project.ownerId,
      effortHours: 0, 
      startDate: project.startDate,
      endDate: project.endDate,
      status: WorkTaskStatus.TODO,
      recurrence: TaskRecurrence.NONE
    };

    return [...currentWorkTasks, autoGeneratedTask];
  };

  const handleAddProject = (newProject: Project) => {
    // 1. Add to projects list
    setProjects(prev => [newProject, ...prev]);

    // 2. ONLY add to Work Tasks as a Main Task if status is CONFIRMED
    if (newProject.status === ProjectStatus.CONFIRMED) {
      setWorkTasks(prev => createWorkTaskFromProject(newProject, prev));
      
      // Also add to central task list if confirmed
      if (newProject.tasks.length > 0) {
        setCentralTaskList(prev => [...prev, ...newProject.tasks]);
      }
    }
  };

  const handleUpdateProject = (id: string, updates: Partial<Project>) => {
    setProjects(prevProjects => {
      return prevProjects.map(p => {
        if (p.id === id) {
          const oldStatus = p.status;
          const updated = { ...p, ...updates };
          
          // Detect transition to CONFIRMED
          if (oldStatus !== ProjectStatus.CONFIRMED && updated.status === ProjectStatus.CONFIRMED) {
            // Trigger WorkTask creation
            setWorkTasks(currentWorkTasks => createWorkTaskFromProject(updated, currentWorkTasks));

            // Trigger CentralTaskList population
            const existingTaskIds = new Set(centralTaskList.map(t => t.id));
            const newTasks = updated.tasks.filter(t => !existingTaskIds.has(t.id));
            if (newTasks.length > 0) {
              setCentralTaskList(currentTasks => [...currentTasks, ...newTasks]);
            }
          }
          return updated;
        }
        return p;
      });
    });
  };

  // Team management handlers
  const handleAddMember = (newMember: TeamMember) => {
    setTeam(prev => [...prev, newMember]);
  };

  const handleUpdateMember = (id: string, updates: Partial<TeamMember>) => {
    setTeam(prev => prev.map(m => m.id === id ? { ...m, ...updates } : m));
  };

  const handleRemoveMember = (id: string) => {
    setTeam(prev => prev.filter(m => m.id !== id));
  };

  // Helper to recalculate parent effort based on children
  const syncParentEffort = useCallback((parentId: string, currentTasks: WorkTask[]) => {
    const children = currentTasks.filter(t => t.parentId === parentId);
    const totalEffort = children.reduce((sum, child) => sum + child.effortHours, 0);
    
    return currentTasks.map(t => 
      t.id === parentId ? { ...t, effortHours: totalEffort } : t
    );
  }, []);

  // WorkTask handlers with automatic effort aggregation
  const handleAddWorkTask = (newTask: WorkTask) => {
    setWorkTasks(prev => {
      const updatedList = [...prev, newTask];
      if (newTask.parentId) {
        return syncParentEffort(newTask.parentId, updatedList);
      }
      return updatedList;
    });
  };

  const handleUpdateWorkTask = (id: string, updates: Partial<WorkTask>) => {
    setWorkTasks(prev => {
      const updatedList = prev.map(t => t.id === id ? { ...t, ...updates } : t);
      const affectedTask = updatedList.find(t => t.id === id);
      
      if (affectedTask?.parentId) {
        return syncParentEffort(affectedTask.parentId, updatedList);
      }
      return updatedList;
    });
  };

  const handleRemoveWorkTask = (id: string) => {
    setWorkTasks(prev => {
      const taskToRemove = prev.find(t => t.id === id);
      const parentId = taskToRemove?.parentId;
      
      // Cascading delete: Remove the task and all its children
      let updatedList = prev.filter(t => t.id !== id && t.parentId !== id);
      
      // If we removed a child, update the parent's effort
      if (parentId) {
        updatedList = syncParentEffort(parentId, updatedList);
      }
      
      return updatedList;
    });
  };

  // Convert Projects to typed Order objects for Dashboard and Team stats
  const ordersForDashboard: Order[] = projects.map(p => ({
    id: p.id,
    title: p.name,
    description: p.description,
    priority: (p.category === ProjectCategory.CTB ? OrderPriority.HIGH : OrderPriority.MEDIUM) as OrderPriority,
    assignedTo: p.ownerId,
    ownerId: p.ownerId,
    status: p.status === ProjectStatus.CONFIRMED ? 'Completed' : p.status === ProjectStatus.PENDING ? 'In Progress' : 'Pending',
    createdAt: p.createdAt,
    tags: [p.category]
  }));

  const renderView = () => {
    switch (view) {
      case 'dashboard':
        return <Dashboard orders={ordersForDashboard} team={team} tasks={workTasks} />;
      case 'orders':
        return (
          <OrderBook 
            projects={projects} 
            team={team} 
            onAddProject={handleAddProject} 
            onUpdateProject={handleUpdateProject}
          />
        );
      case 'team':
        return (
          <TeamManagement 
            team={team} 
            orders={ordersForDashboard} 
            onAddMember={handleAddMember}
            onUpdateMember={handleUpdateMember}
            onRemoveMember={handleRemoveMember}
          />
        );
      case 'tasks':
        return (
          <TaskList 
            tasks={workTasks} 
            team={team} 
            onAddTask={handleAddWorkTask} 
            onUpdateTask={handleUpdateWorkTask}
            onRemoveTask={handleRemoveWorkTask}
          />
        );
      default:
        return <Dashboard orders={ordersForDashboard} team={team} tasks={workTasks} />;
    }
  };

  return (
    <div className="flex min-h-screen bg-gray-50">
      <Sidebar currentView={view} setView={setView} />
      
      <main className="flex-1 p-8 lg:p-12 overflow-y-auto max-h-screen">
        <div className="max-w-7xl mx-auto">
          {renderView()}
          
          {(view === 'orders' || view === 'dashboard') && centralTaskList.length > 0 && (
            <div className="mt-12 bg-indigo-900 text-white rounded-[2rem] p-10 shadow-xl relative overflow-hidden">
              <div className="relative z-10">
                <h3 className="text-2xl font-bold mb-2 flex items-center gap-3">
                  <i className="fas fa-tasks"></i>
                  Central Task List
                </h3>
                <p className="text-indigo-200 mb-8 max-w-xl">Tasks from confirmed projects are automatically piped here for execution tracking.</p>
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                  {centralTaskList.slice(-4).map((task) => (
                    <div key={task.id} className="bg-white/10 backdrop-blur-md p-4 rounded-2xl flex justify-between items-center border border-white/10">
                      <div>
                        <p className="text-sm font-bold">{task.title}</p>
                        <p className="text-[10px] opacity-60 uppercase font-black tracking-widest mt-1">Est: {task.effortDays} Days</p>
                      </div>
                      <div className="bg-indigo-500/30 px-3 py-1 rounded-lg text-[10px] font-bold uppercase">{task.status}</div>
                    </div>
                  ))}
                  {centralTaskList.length > 4 && (
                    <div className="col-span-2 text-center text-xs text-indigo-300 font-bold mt-2">
                      + {centralTaskList.length - 4} more tasks tracked in the global queue
                    </div>
                  )}
                </div>
              </div>
              <div className="absolute top-0 right-0 w-64 h-64 bg-white/5 rounded-full -translate-y-1/2 translate-x-1/3 blur-3xl"></div>
            </div>
          )}
        </div>
      </main>

      <div className="md:hidden fixed bottom-0 left-0 right-0 bg-white border-t border-gray-200 px-6 py-3 flex justify-around items-center z-40">
        <button onClick={() => setView('dashboard')} className={view === 'dashboard' ? 'text-indigo-600' : 'text-gray-400'}>
          <i className="fas fa-home text-xl"></i>
        </button>
        <button onClick={() => setView('orders')} className={view === 'orders' ? 'text-indigo-600' : 'text-gray-400'}>
          <i className="fas fa-book text-xl"></i>
        </button>
        <button onClick={() => setView('team')} className={view === 'team' ? 'text-indigo-600' : 'text-gray-400'}>
          <i className="fas fa-users text-xl"></i>
        </button>
        <button onClick={() => setView('tasks')} className={view === 'tasks' ? 'text-indigo-600' : 'text-gray-400'}>
          <i className="fas fa-list-check text-xl"></i>
        </button>
      </div>
    </div>
  );
};

export default App;